{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Hedgehog.Extras.Internal.Process 
  ( binDist
  , liftIOAnnotated
  , planJsonFile
  ) where

import           Control.Applicative (pure, (<|>))
import           Control.Exception.Annotated (exceptionWithCallStack)
import           Control.Monad (Monad (..), unless)
import           Control.Monad.Catch 
import           Control.Monad.IO.Class (MonadIO, liftIO)
import           Data.Aeson (eitherDecode)
import           Data.Bool (otherwise)
import           Data.Either (Either (..))
import           Data.Eq (Eq (..))
import           Data.Function (($), (.))
import           Data.Functor ((<$>))
import           Data.Maybe (Maybe (..))
import           Data.Monoid ((<>))
import           Data.String (IsString (..), String)
import           GHC.Stack (HasCallStack)
import           Hedgehog.Extras.Internal.Plan (Component (..), Plan (..))
import           Prelude (error)
import           System.FilePath (takeDirectory)
import           System.FilePath.Posix ((</>))
import           System.IO (FilePath, IO)
import           Text.Show (Show (show))

import qualified Data.ByteString.Lazy as LBS
import qualified Data.List as L
import           Data.Text (Text)
import qualified Data.Text as T
import qualified GHC.Stack as GHC
import qualified Hedgehog.Extras.Stock.OS as OS
import qualified System.Directory as IO
import qualified System.Environment as IO
import qualified System.IO.Unsafe as IO

-- | Consult the "plan.json" generated by cabal to get the path to the executable corresponding.
-- to a haskell package.  It is assumed that the project has already been configured and the
-- executable has been built.
-- Throws an exception on failure.
binDist
  :: (HasCallStack, MonadIO m)
  => String
  -- ^ Package name
  -> String
  -- ^ Environment variable pointing to the binary to run (used for error messages only)
  -> m FilePath
  -- ^ Path to executable
binDist pkg binaryEnv = do
  doesPlanExist <- liftIOAnnotated $ IO.doesFileExist planJsonFile
  unless doesPlanExist $
    error $ "Could not find plan.json in the path: "
              <> planJsonFile
              <> ". Please run \"cabal build "
              <> pkg
              <> "\" if you are working with sources. Otherwise define "
              <> binaryEnv
              <> " and have it point to the executable you want."

  Plan{installPlan} <- eitherDecode <$> liftIOAnnotated (LBS.readFile planJsonFile)
      >>= \case
        Left message -> error $ "Cannot decode plan in " <> planJsonFile <> ": " <> message
        Right plan -> pure plan

  let componentName = "exe:" <> fromString pkg
  case findComponent componentName installPlan of
    Just Component{binFile=Just binFilePath} -> pure . addExeSuffix $ T.unpack binFilePath
    Just component@Component{binFile=Nothing} ->
      error $ "missing \"bin-file\" key in plan component: " <> show component <> " in the plan in: " <> planJsonFile
    Nothing ->
      error $ "Cannot find \"component-name\" key with the value \"exe:" <> pkg <> "\" in the plan in: " <> planJsonFile
  where
    findComponent :: Text -> [Component] -> Maybe Component
    findComponent _ [] = Nothing
    findComponent needle (c@Component{componentName, components}:topLevelComponents)
      | componentName == Just needle = Just c
      | otherwise = findComponent needle topLevelComponents <|> findComponent needle components

-- This will also catch async exceptions as well.
liftIOAnnotated :: (HasCallStack, MonadIO m) => IO a -> m a
liftIOAnnotated action = GHC.withFrozenCallStack $
  liftIO $ action `catch` (\(e :: SomeException) -> throwM $ exceptionWithCallStack e)

-- | Discover the location of the plan.json file.
planJsonFile :: String
planJsonFile = IO.unsafePerformIO $ do
  maybeBuildDir <- liftIOAnnotated $ IO.lookupEnv "CABAL_BUILDDIR"
  case maybeBuildDir of
    Just buildDir -> return $ ".." </> buildDir </> "cache/plan.json"
    Nothing -> findDefaultPlanJsonFile
{-# NOINLINE planJsonFile #-}

-- | Find the nearest plan.json going upwards from the current directory.
findDefaultPlanJsonFile :: IO FilePath
findDefaultPlanJsonFile = IO.getCurrentDirectory >>= go
  where go :: FilePath -> IO FilePath
        go d = do
          let planRelPath = "dist-newstyle/cache/plan.json"
              file = d </> planRelPath
          exists <- IO.doesFileExist file
          if exists
            then return file
            else do
              let parent = takeDirectory d
              if parent == d
                then return planRelPath
                else go parent

addExeSuffix :: String -> String
addExeSuffix s = if ".exe" `L.isSuffixOf` s
  then s
  else s <> exeSuffix


exeSuffix :: String
exeSuffix = if OS.isWin32 then ".exe" else ""
